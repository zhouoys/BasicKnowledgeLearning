# 笔记

## 文件操作路径和模块标识路径问题

### git中配置忽略文件

在vscoede中配置git忽略文件，也就是.gitignore文件

因为node_modules过大，一般不做上传。

操作

1. 在需要上传的文件夹下右键选择Git Bash 进入命令行，进入项目所在目录。
2. 输入 touch .gitignore ，生成“.gitignore”文件（生成时已经设置好了）。

常用的规则

1. /mtk/ 过滤整个文件夹，例：node_modules/
2. ip *.z  过滤zip后缀文件
3. /mtk/do.c   过滤该文件，例：demo.html
4. 前面加 ！，表示不过滤此项，例：!src/ 或者 !*.js 或者 !index.html

~~~txt
.DS_Store
node_modules/
platforms/
dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
package-lock.json

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
~~~





### 文件操作路径



文件操作中的相对路径`./`可以省略，例如：`fs.readFile('data/a.txt')`但是一般为了代码清晰，明了，不建议省略 `./`  应该尽可能写成 `fs.readFile('./data/a.txt')` 形式

![image-20200517175116120](第四天笔记.assets/image-20200517175116120.png)

在模块加载过程中，相对路径中的`./`不可以省略，`Error:Cannot find module 'data/foo.js'`

`require('data/foo.js')`

### 请求模块路径

![image-20200517175222473](第四天笔记.assets/image-20200517175222473.png)





## 使用nodemon工具自动重启服务

### 修改完代码自动重启

我们这里可以使用一个第三方开发的工具：`nodemon` 来帮助我们解决频繁修改代码重启服务器问题。

`nodemon` 是一个基于Node.js开发的一个第三方命令行工具，我们使用的时候需要独立安装。

当前项目局部安装

~~~shell
# 在任意目录下执行该命令都可以
# 也就是说，所有需要 --global来安装的包都可以在任意目录执行
npm install nodemon --save
~~~

全局安装

~~~shell
# 采用cnpm 方式
cnpm install -g  nodemon 

# 采用npm方式，已经设置淘宝镜像 ，最好是全局安装，因为它是一个服务器工具而不是一个依赖包，且多个项目使用
npm install nodemon -g
~~~



安装完毕之后，使用:

~~~shell
# 执行此命令则依旧采用node模式运行，也就是不会重启服务器
node app.js
# 使用nodemon
nodemon app.js
~~~

只要是通过 `nodemon app.js` 启动的服务，则它会监视你的文件变化，当文件发生变化的时候，自动帮你重启服务器。



## express 

### 起步

#### 安装

~~~shell
npm install --save express
~~~



#### hello world

~~~shell
const express = require('express');
const app = express();
const part = 9000;
app.get('/',function(request,response){
    response.send('hello world Express')
})
app.listen(part,() =>{
    console.log('the express server is starting');
})
~~~



#### 基本路由

基本路由组成：

+ 请求方法
+ 请求路径
+ 请求处理函数

get:

~~~shell
// 当以GET方法请求 / 的时候，执行对应的处理函数
app.get('/',function(request,response){
    response.send('hello world Express')
})
~~~

post:

~~~shell
// 当以POST方法请求 / 的时候，指定对应的处理函数
app.post('/',function(req,res){
res.send('Got a POST request')
})
~~~



#### 静态服务



![image-20200517192456573](第四天笔记.assets/image-20200517192456573.png)

~~~shell
// /public资源,也就是url可以省略 /public这种方式，例如：http://localhost:9000/img/01.jpg这种形式
app.use(express.static('public'));

// files资源 http://localhost:9000/01.css，不需要添加/files,就可以访问了。
app.use(express.static('files'));

// /public/public资源  http://localhost:9000/public/01.jpg
app.use('/public',express.static('public'));

// /static/static资源   // http://localhost:9000/static/01.jpg
app.use('/static',express.static('public'));
// 暂时用不上
app.use('/static',express.static(path.join(_dirname,'public')))
~~~



### 在Express中配置使用art-template模板引擎

#### 安装

**art-template中对于express做了特殊的兼容性处理，可以直接在art-template中搜索使用**



安装，必须要安装 art-template 然后再安装 express-art-template，因为前者需要后者的依赖项。

![image-20200517213838246](第四天笔记.assets/image-20200517213838246.png)



#### 使用示例

![image-20200517214214288](第四天笔记.assets/image-20200517214214288.png)





#### 服务器中的配置

![image-20200517214430494](第四天笔记.assets/image-20200517214430494.png)



#### 核心配置

~~~javascript
var template = require('art-template'); // 引入art-template模板引擎模块。
// 第一个参数 .art 表示当渲染以.art结尾的文件的时候，使用art-template模板引擎
// express-art-template是专门用来在Express中把art-template整合到Express中，其依赖于art-template
app.engine('art',require('express-art-template'));
~~~



![image-20200517214742634](第四天笔记.assets/image-20200517214742634.png)

#### 使用配置

~~~shell
# Express 为Response相应对象提供了一个方法：render
# render方法默认是不可以使用的，但是如果配置了模板引擎就可以使用了
# res.render('html模板名',{模板数据})
# 第一个参数不能写路径，默认会去项目中的views目录查找该模板文件
# 也就是说Express中有一个约定:开发人员把所有的视图文件都放到 views目录中
~~~

#### 在路由中使用

~~~javascript
app.get('/',function(req,res){
    res.render('404.art');
})
~~~





如果将`html`文件改为`art`文件的话，固然`app.engine('art',...)`，那么可是编辑器一般不能高亮显示代码，所以为了,更好处理，可以直接将`app.engine('html',...)`, 所谓山不转人转就是这个道理。

![image-20200517214714093](第四天笔记.assets/image-20200517214714093.png)



#### 修改要渲染的文件的后缀名，默认为art,此处改成html

![image-20200517214852728](第四天笔记.assets/image-20200517214852728.png)



#### 可以直接渲染文件，可以不需要渲染数据进去。

![image-20200517214959586](第四天笔记.assets/image-20200517214959586.png)



#### 添加渲染数据

![image-20200517215053914](第四天笔记.assets/image-20200517215053914.png)



#### 修改默认的渲染路径

![image-20200517215206632](第四天笔记.assets/image-20200517215206632.png)



~~~javascript
// express 中art-template渲染路径默认为views
// 可以通过手动更改默认的html渲染路径
app.set('views','render函数的默认路径')
// app.set('views','page')
// 尝试设置多条路径
// app.set('views','default/demo');
~~~











安装:

~~~shell
npm install --save art-template
npm install --save express-art-template
~~~



配置:

~~~javascript
app.engine('art',require('express-art-template'))
// 此处的art指的是要渲染的文件的后缀名，一般可以手动改成html
~~~



使用:

~~~javascript
app.get('/',function(req,res){
//express默认会去项目中的views目录中找index.html
res.render('index.html',{
title:'hello world'
})
})
~~~



如果希望修改默认的`views`视图渲染存储目录，可以：

~~~javascript
app.set('view',目录路径)
~~~



#### 使用Express重写留言板案例

![image-20200517220204872](第四天笔记.assets/image-20200517220204872.png)



#### express自带的重定向功能

![image-20200517220409705](第四天笔记.assets/image-20200517220409705.png)



~~~javasc
// express自带重定向功能
res.redirect('/');
~~~



~~~javascript
/**
 * 使用express+art-template重写留言板案例
 */
// 引包
var express = require('express');
var template = require('art-template');
// post请求单独处理
var bodyParser = require('body-parser')
// 创建数据
var commentList = [
    {id:'10001',
     name:'silly',
     comment:'hello world',
     dateTime:'2019-12-12 09:26:45'
    },
    {id:'10002',
    name:'silly',
    comment:'hello world',
    dateTime:'2019-12-12 09:26:45'
   },
   {id:'10003',
   name:'silly',
   comment:'hello world',
   dateTime:'2019-12-12 09:26:45'
  },
  {id:'10004',
  name:'silly',
  comment:'hello world',
  dateTime:'2019-12-12 09:26:45'
 }]
// 创建服务器
var app = express();
// 配置express-art-template
app.engine('html',require('express-art-template'));
// 配置body-parser
app.use(bodyParser.urlencoded({extended:false}));
app.use(bodyParser.json())
// 配置开放静态资源
app.use('/node_modules/',express.static('./node_modules'));
app.use('/public/',express.static('./public'))
// 处理 首页请求
app.get('/index',function(request,response){
    response.render('index.html',{
        title:'留言板案例',
        commonList:commentList
    })
})
// 保存新添加的评论记录
app.post('/index',function(request,response){
    var comment = request.body; // 直接使用body-parser技术
    comment.id = new Date().getTime().toString();
    comment.dateTime = '2020-02-02 02-20-22';
    commentList.unshift(comment);
    response.redirect('/index');
})

// 处理 添加请求
app.get('/addItem',function(request,response){
    response.render('addItem.html')
})
// 监听端口
app.listen(3000,function(){
    console.log('the server is running');
})
~~~





### 在Express 中配置解析表单post请求体数据



#### post概述

在post.html页面中配置表单提交为 `action="/post" method="post" `,也就是将表单请求改为post请求方式，那么此时如何获取 `form Data` 请求体中的参数呢？

![image-20200517221147378](第四天笔记.assets/image-20200517221147378.png)



在Express中无法直接获取post请求方式中的请求体中的数据，需要依赖第三方的中间件提供的API接口来获取

![image-20200517221524213](第四天笔记.assets/image-20200517221524213.png)

MiddleWare也就是 "中间件"的意思。



#### 安装body-parser中间件

这是一个插件，专门用来解析POST请求的请求体中的参数信息。

![image-20200517221557602](第四天笔记.assets/image-20200517221557602.png)



~~~shell
npm install body-parser --save
~~~



#### 配置body-parser

##### 第一步：引包

![image-20200517222014350](第四天笔记.assets/image-20200517222014350.png)



~~~javascript
var bodyParser = require('body-parser')
~~~



##### 第二步：配置中间件

![image-20200517221923329](第四天笔记.assets/image-20200517221923329.png)

配置body-parser

只要加入这个配置，则在req请求对象上会多出来一个属性body

也就是可以直接通过req.body来获取表单POST请求体数据了

配置项目:

~~~javascript
app.use(bodyParser.urlencoded({extended:false}));
app.use(bodyParser.json());
~~~



##### 第三步：使用

![image-20200517233020639](第四天笔记.assets/image-20200517233020639.png)



~~~javascript
var comment = req.body
~~~

直接在`post`路由中通过`request.body` 来获取请求体,同时可以看到路由中的`response.send()`都没有添加return结束请求的设置，因为在express已经对响应的结束自动做了处理。



~~~javascript
var express = require('express')
var bodyParser = require('body-parser')
var app = express()
// parse application/x-www-form-urlencoded
app.use(bodyParser.urlencoded({ extended: false }))

// parse application/json
app.use(bodyParser.json())

app.use(function (req, res) {
  res.setHeader('Content-Type', 'text/plain')
  res.write('you posted:\n')
  res.end(JSON.stringify(req.body, null, 2))
})

~~~



~~~javascript
var express = require('express')
var bodyParser = require('body-parser')
var app = express()

// create application/json parser
var jsonParser = bodyParser.json()

// create application/x-www-form-urlencoded parser
var urlencodedParser = bodyParser.urlencoded({ extended: false })

// POST /login gets urlencoded bodies
app.post('/login', urlencodedParser, function (req, res) {
  res.send('welcome, ' + req.body.username)
})

// POST /api/users gets JSON bodies
app.post('/api/users', jsonParser, function (req, res) {
  // create user in req.body
})

~~~



##### 补充知识

Post请求的两种编码格式：application/x-www-form-urlencoded和multipart/form-data

在常见业务开发中，POST请求常常在这些地方使用：前端表单提交时、调用接口代码时和使用Postman测试接口时。我们下面来一一了解：



POST请求的两种编码格式：`application/x-www-urlencoded`是浏览器默认的编码格式，用于键值对参数，参数之间用`&`间隔；`multipart/form-data`常用于文件等二进制，也可用于键值对参数，最后连接成一串字符传输(参考Java OK HTTP)。除了这两个编码格式，还有`application/json`也经常使用。



作者：DeppWang
链接：https://www.jianshu.com/p/53b5bd0f1d44
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 在Express中配置解析表单get中的url请求数据

在Express内置了一个API,可以直接通过`request.query` 来获取

~~~javascript
request.query
~~~





## CRUD起步



![image-20200519145917325](第四天笔记.assets/image-20200519145917325.png)





![image-20200519150036887](第四天笔记.assets/image-20200519150036887.png)





![image-20200519150339087](第四天笔记.assets/image-20200519150339087.png)





![image-20200519150410140](第四天笔记.assets/image-20200519150410140.png)





![image-20200519150617895](第四天笔记.assets/image-20200519150617895.png)







## 从文件中读取数据



![image-20200519151301002](第四天笔记.assets/image-20200519151301002.png)





![image-20200519151435374](第四天笔记.assets/image-20200519151435374.png)







![image-20200519151849305](第四天笔记.assets/image-20200519151849305.png)





![image-20200519151932454](第四天笔记.assets/image-20200519151932454.png)





## CRUD设置路由

| 请求方法 | 请求路径         | get 参数 | post 参数                      | 备注             |
| -------- | ---------------- | -------- | ------------------------------ | ---------------- |
| GET      | /studens         |          |                                | 渲染首页         |
| GET      | /students/new    |          |                                | 渲染添加学生页面 |
| POST     | /studens/new     |          | name、age、gender、hobbies     | 处理添加学生请求 |
| GET      | /students/edit   | id       |                                | 渲染编辑页面     |
| POST     | /studens/edit    |          | id、name、age、gender、hobbies | 处理编辑请求     |
| GET      | /students/delete | id       |                                | 处理删除请求     |
|          |                  |          |                                |                  |





## 路由模块的提取



![image-20200519162733984](第四天笔记.assets/image-20200519162733984.png)





![image-20200519163050572](第四天笔记.assets/image-20200519163050572.png)







![image-20200519163524646](第四天笔记.assets/image-20200519163524646.png)





![image-20200519163623454](第四天笔记.assets/image-20200519163623454.png)





![image-20200519164033920](第四天笔记.assets/image-20200519164033920.png)





![image-20200519164407681](第四天笔记.assets/image-20200519164407681.png)





## 处理添加页面以及配置



![image-20200519182949434](第四天笔记.assets/image-20200519182949434.png)



## 封装提取Student数据操作模块



![image-20200519183829810](第四天笔记.assets/image-20200519183829810.png)





### 封装异步的API



![image-20200519184904250](第四天笔记.assets/image-20200519184904250.png)





![image-20200519185205387](第四天笔记.assets/image-20200519185205387.png)





![image-20200519185357075](第四天笔记.assets/image-20200519185357075.png)





![image-20200519185447423](第四天笔记.assets/image-20200519185447423.png)





## 封装保存学生的API



![image-20200519214521098](第四天笔记.assets/image-20200519214521098.png)





![image-20200519215017615](第四天笔记.assets/image-20200519215017615.png)



![image-20200519215044326](第四天笔记.assets/image-20200519215044326.png)





![image-20200519215332145](第四天笔记.assets/image-20200519215332145.png)





## 强调回掉函数



![image-20200519220047468](第四天笔记.assets/image-20200519220047468.png)





## 完成渲染编辑学生页面



![image-20200519220529651](第四天笔记.assets/image-20200519220529651.png)





![image-20200519220737307](第四天笔记.assets/image-20200519220737307.png)





![image-20200519221059980](第四天笔记.assets/image-20200519221059980.png)





![image-20200519221327051](第四天笔记.assets/image-20200519221327051.png)





![image-20200519221518102](第四天笔记.assets/image-20200519221518102.png)







![image-20200519221654681](第四天笔记.assets/image-20200519221654681.png)





## 实现更新功能



![image-20200519222513552](第四天笔记.assets/image-20200519222513552.png)





## 完成删除功能

![image-20200519223523213](第四天笔记.assets/image-20200519223523213.png)





![image-20200519223556957](第四天笔记.assets/image-20200519223556957.png)





![image-20200519223651052](第四天笔记.assets/image-20200519223651052.png)





